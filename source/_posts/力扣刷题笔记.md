---
title: 力扣刷题笔记
date: 2024-10-10 17:26:08
tags: leetcode
categories: 编程学习
---
   2024年力扣刷题笔记
<!--more-->
## 简单难度
### 计数器
请你写一个函数 createCounter。这个函数接收一个初始的整数值 init。并返回一个包含三个函数的对象。
这三个函数是：
increment() 将当前值加 1 并返回。
decrement() 将当前值减 1 并返回。
reset() 将当前值设置为 init 并返回。
```Javascript
var createCounter = function(init){
    let count = init;
    return{
        increment:function(){
            count++;
            return count;
        },
        decrement:function(){
            count--;
            return count;
        },
        reset:function(){
            count = init;
            return count;
        }
    }
}
```
* <font color=red>定义一个新对象，直接用大括号引入，或用对象字面量/构造函数/class语法/object.create()方法创建</font>
* <font color=red>方法间用逗号隔开，并用冒号 : 进行定义</font>

### 数组原型对象的最后一个元素
请你编写一段代码实现一个数组方法，使任何数组都可以调用 array.last() 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 -1 。
```Javascript
    Array.prototype.last = function() {
        if (this.length == 0){ 
            return -1;
        }else{
            let len = this.length;
            return this[len - 1]; 
        }
    };
```
<font color=red>注意：在函数中并未传入数组参数，使用this指向调用该方法的对象</font>

### 睡眠函数
请你编写一个异步函数，它接收一个正整数参数 millis ，并休眠 millis 毫秒。要求此函数可以解析任何值。
```Javascript
示例 1：
输入：millis = 100
输出：100
解释：
在 100ms 后此异步函数执行完时返回一个 Promise 对象
let t = Date.now();
sleep(100).then(() => {
  console.log(Date.now() - t); // 100
});
```
   ```Javascript
   async function sleep(millis) {
          return new Promise(（resolve） =>{
            setTimeout(() => {resolve(millis)}, millis);
          } 
    }
```

* <font color=red>题目要求返回一个对象  </font>
* <font color=red>利用resolve参数，改变Promise状态，进而传递参数</font>
* <font color=red>Promise是Js的一个内置对象，用于表示一个异步操作的状态，而不是所有对象都是new Promise()</font>

### 生成斐波那契数列
请你编写一个生成器函数，并返回一个可以生成 斐波那契数列 的生成器对象。
斐波那契数列 的递推公式为 Xn = Xn-1 + Xn-2 。
这个数列的前几个数字是 0, 1, 1, 2, 3, 5, 8, 13 。
```Javascript
var fibGenerator = function*() {
    let a = 0;
    let b = 1;
    let c;
    while(1){
        yield a;
        c = a;
        a = a + b;
        b = c;
    }
}
```
* <font color=red>yield：是js中用来定义生成器函数的关键字，可在函数中暂停执行，并返回一个值，下次调用next（）方法时，从上次暂停的地方继续执行</font>
* <font color=red>生成器函数：通过在函数定义前加上星号 * 来创建一个生成器函数，例如 function* myGenerator() {} </font>


### 数组分块
给定一个数组 arr 和一个块大小 size ，返回一个 分块 的数组。
分块 的数组包含了 arr 中的原始元素，但是每个子数组的长度都是 size 。如果 arr.length 不能被 size 整除，那么最后一个子数组的长度可能小于 size 。
你可以假设该数组是 JSON.parse 的输出结果。换句话说，它是有效的JSON。
请你在不使用 lodash 的函数 _.chunk 的情况下解决这个问题。
```Javascript
var chunk = function(arr, size) {
    const arrRes = [];
    while(arr.length) {
        arrRes.push(arr.splice(0, size));
    }
    return arrRes;
};
```
* <font color=red>使用数组常用方法splice或slice解决</font>

### 包装数组
创建一个名为 ArrayWrapper 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：
当使用 + 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。
当在实例上调用 String() 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，[1,2,3] 。
```Javascript
var ArrayWrapper = function(nums) {
    // 将传入的数组赋值给实例属性
    this.nums = nums;
};
ArrayWrapper.prototype.valueOf = function() {
    // 计算数组中所有元素的和并返回
    return this.nums.reduce((sum, num) => sum + num, 0);
}
ArrayWrapper.prototype.toString = function() {
    // 将数组转换为字符串格式
    return `[${this.nums.join(',')}]`;
}
```
* <font color=red>模板字符串，${}引用表达式</font>
* <font color=red>使用 throw new Error('这是一个错误信息') 抛出异常</font>

### 执行可取消的延迟函数
给定一个函数 fn ，一个参数数组 args 和一个以毫秒为单位的超时时间 t ，返回一个取消函数 cancelFn 。
在 cancelTimeMs 的延迟后，返回的取消函数 cancelFn 将被调用。
setTimeout(cancelFn, cancelTimeMs)
最初，函数 fn 的执行应该延迟 t 毫秒。
如果在 t 毫秒的延迟之前调用了函数 cancelFn，它应该取消 fn 的延迟执行。否则，如果在指定的延迟 t 内没有调用 cancelFn，则应执行 fn，并使用提供的 args 作为参数。
```Javascript
示例 1:

输入：fn = (x) => x * 5, args = [2], t = 20
输出：[{"time": 20, "returned": 10}]
解释：
const cancelTimeMs = 50;
const cancelFn = cancellable((x) => x * 5, [2], 20);
setTimeout(cancelFn, cancelTimeMs);

取消操作被安排在延迟了 cancelTimeMs（50毫秒）后进行，这发生在 fn(2) 在20毫秒时执行之后。
```
```Javascript
Var cancellable = function(fn,args,t){
    let timeoutID;
    const cancelFn = function(){
        clearTimeout(timeoutID);
    }
    timeoutID = setTimeout(()=>{fn(args);},t);
    Return cancelFn;
}
```
* <font color=red>注意题目中对cancelFn的功能需求，第二个setTimout函数是在cancellable之外执行，本很熟只需要创建一个函数，调用能取消setTimeout的函数即可</font>

### 排序方式
给定一个数组 arr 和一个函数 fn，返回一个排序后的数组 sortedArr。你可以假设 fn 只返回数字，并且这些数字决定了 sortedArr 的排序顺序。sortedArr 必须按照 fn 的输出值 升序 排序。
```Javascript
var sortBy = function(arr, fn) {
    let sortedArr = arr.sort((a,b)=>fn(a)-fn(b));
    return sortedArr
}
```
* <font color=red>.sort()方法可以接收一个比较函数，该函数接收两个参数，返回一个负数、零或正数，用来决定两个元素的相对顺序。
负数：第一个参数排在第二个参数前；
正数：第一个参数排在第二个参数后；
零：两个参数相等。</font>

### 间隔取消（setTimeout重复调用）
现给定一个函数 fn，一个参数数组 args 和一个时间间隔 t，返回一个取消函数 cancelFn。

在经过 cancelTimeMs 毫秒的延迟后，将调用返回的取消函数 cancelFn。

setTimeout(cancelFn, cancelTimeMs)
函数 fn 应立即使用参数 args 调用，然后每隔 t 毫秒调用一次，直到在 cancelTimeMs 毫秒时调用 cancelFn。
```javascript
var cancellable = function(fn, args, t) {
    let timeoutID;
    let status = true;
    const cancleFn = function(){
        clearTimeout(timeoutID);
        status = false;
    }
    const repeatsetTime = function(){
        if(status){//判断条件在函数内部进行循环
            fn(...args);//使用...args展开参数数组，fn接收任意数量的参数
            timeoutID = setTimeout(repeatsetTime,t);//每次都调用repeatsetTime，而非fn（...args）
        }
    }
    fn(...args);
    timeoutID = setTimeout(repeatsetTime,t);//启动第一次调用
    return cancleFn;
};
```
* <font color=red>也可以使用setInterval实现间隔调用，但是需要注意 clearInterval的使用</font>
* <font color=red>正确的幂运算 result = Math.pow(a,x)</font>

### 判断为空
给定一个对象或数组，判断它是否为空。

一个空对象不包含任何键值对。
一个空数组不包含任何元素。
你可以假设对象或数组是通过 JSON.parse 解析得到的。

 ```javascript
 var isEmpty = function(obj) {
    if(Array.isArray(obj)){
        if(obj.length == 0){
            return true
        }else{
            return false
        }
    }else if(typeof obj === 'object' && obj !== null){
        return Object.keys(obj).length === 0;
    }else{
        return false
    }
};
```
* <font color=red>typeof null === 'object'，所以需要判断null</font>
* <font color=red>Object.keys()返回一个数组，包含对象obj的键值;length属性返回数组的长度</font>
