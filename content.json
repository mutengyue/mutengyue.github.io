{"meta":{"title":"MTY's Blog","subtitle":"","description":"","author":"MTY","url":"https://Cynthia1379.github.io","root":"/"},"pages":[{"title":"categories","date":"2024-10-28T07:10:48.000Z","updated":"2024-10-29T10:36:19.505Z","comments":true,"path":"categories/index.html","permalink":"https://cynthia1379.github.io/categories/index.html","excerpt":"","text":""},{"title":"ABOUT","date":"2024-10-25T13:52:16.000Z","updated":"2024-10-29T10:36:19.495Z","comments":true,"path":"ABOUT/index.html","permalink":"https://cynthia1379.github.io/ABOUT/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-10-28T07:12:04.000Z","updated":"2024-11-06T02:26:18.389Z","comments":true,"path":"tags/index.html","permalink":"https://cynthia1379.github.io/tags/index.html","excerpt":"","text":"标签列表 UI设计 介绍：关于用户界面设计的文章和资源。 Git 介绍：关于 Git 版本控制系统的文章，包括常用命令和技巧。 LeetCode 介绍：与 LeetCode 编程题相关的解决方案和分析。 虚拟机 介绍：关于虚拟机技术的文章，包括使用和配置的指南。 标签下的文章UI设计 UI学习记录 Git Git使用教程 虚拟机 虚拟机安装指南 LeetCode LeetCode刷题笔记"}],"posts":[{"title":"Web前端学习笔记","slug":"Js学习笔记","date":"2024-11-07T02:26:02.000Z","updated":"2024-11-09T02:39:03.443Z","comments":true,"path":"2024/11/07/Js学习笔记/","permalink":"https://cynthia1379.github.io/2024/11/07/Js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Js学习笔记","text":"Js学习笔记 JS系列说说JS中的数据类型？存储上的差别？JS中数据类型分为两大类，基本类型与引用类型，他们间最大的区别是存储上的差别。 基本类型 数值型：Number 字符串型：String 布尔类型：Boolen 空类型:null undefined类型:undefined symbol类型 数值型可以设置为二进制（0b开头）、十进制、八进制（0开头）、十六进制（0x开头）。 1234var num1 = 10;var num2 = 0b1010; // 二进制var num3 = 0o12; // 八进制var num4 = 0x1a; // 十六进制 浮点类型可通过科学计数法表示。 12var num5 = 3.14;var num6 = 1.5e2; // 1.5 * 10^2 此类型存在一个特殊数值NAN，表示“非数值”，即该结果本该是数值类型，但出现错误，无法表示（非抛出错误）。 字符串型用单引号或双引号括起来的任意文本，一旦创建，不可改变。后续所有更改都是创建副本，在副本基础上进行操作。 12var str1 = &#x27;hello&#x27;;var str2 = &quot;world&quot;; 布尔类型只有两个值，true和false。 空类型表示一个空值，null。是一个对象类型，可以赋值给变量。 1var obj = null; 1typeof null // &quot;object&quot; undefined当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值，是一个未定义类型。但和变量未声明仍有明显区别。 引用类型 对象 Object 数组 Array 函数 Function Object对象字面量1234567let Person = &#123; name: &#x27;Tom&#x27;, age: 20, sayHello: function() &#123; console.log(&#x27;Hello,&#x27;+ this.name); &#125;&#125; 构造函数法1234567function Person(name,age)&#123; this.name = &#x27;Tom&#x27;; this.age = 20; this.sayHello = function()&#123; console.log(&quot;hello,&quot;+this.name); &#125;&#125; object.create()方法Object.create(proto) 调用时，会创建一个新对象，并将 proto 作为新对象的原型。新对象会继承 proto 中的属性和方法。 原型链： 新对象与其原型之间建立了原型链关系。当对新对象的属性进行查找时，JavaScript 会首先检查该对象自身是否拥有该属性。如果没有，JavaScript 会沿着原型链向上查找，即查找其原型对象及其原型的原型，直到找到该属性或到达原型链的顶端（Object.prototype）为止。 12345678910let Person = &#123; name: &#x27;Tom&#x27;, age: 20, sayHello: function() &#123; console.log(&#x27;Hello,&#x27;+ this.name); &#125;&#125;let person1 = Object.create(Person);person1.name = &#x27;Jerry&#x27;;person1.sayHello(); // Hello, Jerry Array数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长。创建数组本质就是创建对象，对象的属性可以通过’[]’访问。 1let arr = []; Function函数声明function greet(){ console.log(“Hello, world!”); } 函数表达式let greet &#x3D; function(){ console.log(“Hello,world!”);} 箭头函数const greet &#x3D; () &#x3D;&gt; { console.log(“Hello, world!”);} 存储区别基本类型存储在栈区。引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。obj1是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了obj2，实际上他们共同指向了同一个堆内存对象，所以更改obj2会对obj1产生影响。 数组的常用方法有那些？操作方法增push()接收任意数量参数，将其添加至数组末尾，返回数组最新长度。 1arr.push(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); unshift()接收任意数量参数，将其添加至数组开头，返回数组最新长度。 1arr.unshift(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); splice()接收三个参数（操作开始的位置，删除数据的个数，增加的数据），返回删除的数据组成的新数组，本质上是改数组内容，但也可单独用于增加或删除。 12345let arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];let change = arr.splice(1,2,&#x27;B&#x27;,&#x27;C&#x27;);//arr = [a,B,C,d]let add = arr.splice(1,0,&#x27;A&#x27;);//arr = [a,A,B,C,d]console.log(change);//b,cconsole.log(add);// null concat()创建一个当前数组的副本，将传入参数增加至副本末尾，不影响原数组。 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] 删pop()删除数组最后一项，返回被删除项。 shift()删除数组第一项，返回被删除项。 splice()同上。 slice()Array.prototype.slice 方法用于提取数组的一部分，并返回一个新数组。它的基本语法是： 1array.slice(start, end) start：提取的开始索引（包含该索引的元素）。如果为负数，则表示从数组尾部开始计数。end：提取的结束索引（不包含该索引的元素）。如果省略，则提取到数组的末尾。如果为负数，则表示从数组尾部开始计数。 改 splice查indexOf()查找是否包含传入参数项，返回第一个找到的参数的位置，没找到返回-1. includes()查找是否包含传入参数项，返回布尔值。 find()返回第一个匹配的元素。 1234567891011const people = [ &#123; name: &quot;Matt&quot;, age: 27 &#125;, &#123; name: &quot;Nicholas&quot;, age: 29 &#125;];people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: &quot;Matt&quot;, age: 27&#125; 排序方法reserve将数组元素顺序反转。 123let values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5,4,3,2,1 sort接受一个比较函数，用于判断哪个值应该排在前面，返回经过排序后的数组。默认是根据字符串Unicode编码（字母字典顺序）进行排序 123let numbers = [10, 2, 5, 1, 9];numbers.sort((a, b) =&gt; a - b);console.log(numbers); // 输出: [1, 2, 5, 9, 10] a-b，从小到大顺序排序，b-a，从大到小降序排序。返回值负数：第一个参数排在第二个参数前；返回值正数：第一个参数排在第二个参数后； 转换方法 join()接受一个参数，即字符串分割符，返回包含所有项的字符串。 123let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];alert(colors.join(&quot;,&quot;)); // red,green,bluealert(colors.join(&quot;||&quot;)); // red||green||blue 迭代方法（都不改变原数组）some()传入一个函数，将数组每一项执行此函数，有一项返回true，此方法返回true。 every传入一个函数，将数组每一项执行此函数，每一项返回true，此方法返回true。 forEach()对数组每一项都执行传入的函数，没有返回值。 filter()对数组每一项都执行传入的函数，函数返回为true的项组成新数组返回。 map对函数的每一项都执行传入的函数，每次函数调用的结果组成新数组返回。 JS字符串的常用方法有那些？操作方法增删查改转换方法 split模板匹配方法谈谈JS中的类型转换机制？隐式转换显式转换&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别？等于操作符全等操作符区别浅拷贝深拷贝的区别？如何实现一个深拷贝？数据类型存储浅拷贝深拷贝区别谈谈你对闭包的理解？闭包使用场景？定义使用场景注意事项说说你对作用域链的理解作用域词法作用域作用域链JS原型，原型链？有什么特点？JS中，每一个对象都有一个原型’xxx.prototype’，每个对象都有一个方法’xxx.proto‘指向其构造函数的原型，由此构成原型链。当对象实例调用一个方法时，JavaScript 查找该方法时首先查看对象本身的属性，如果找不到，则会沿着原型链向上查找。 JS如何实现继承？是什么继承（inheritance）是面向对象软件技术当中的一个概念。如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”。例如父类车，子类轿车，货车。子类可以继承父类的一些属性和方法，也可重写或覆盖某些属性和方法。 实现方式原型链继承12345678function Parent()&#123; this.name = &#x27;tom&#x27;; this.age = 23;&#125;function Child()&#123; this.sex = &#x27;girl&#x27;;&#125;Child.prototype = new Parent(); 存在潜在问题： 12s1 = new Child();s2 = new Child(); s1，s2使用相同的一个原型对象，内存空间共享，改变s1，s2页发生变化。 构造函数继承借助call调用Parent函数 1234567891011121314function Parent()&#123; this.name = &#x27;name&#x27;; this.age = 30;&#125;Parent.prototype.getName = function()&#123; return this.name;&#125;function Child()&#123; Parent.call(this);//这里的上下文this指Child //调用 Parent 构造函数，并将新创建的 Child 实例作为 this 传入，这样 name 和 age 属性就会被初始化到新实例中。 this.sex = &#x27;girl&#x27;;&#125;let child = new Child();console.log(child.getName());//报错 优化了原型链继承的弊端，但只能继承父类的实例属性和方法，不能继承原型属性或方法。 组合继承既使用原型链继承，又使用构造函数继承。 1234567891011function Parent()&#123; this.name = &#x27;name&#x27;; this.age = 18;&#125;function Child()&#123; Parent.call(this); sex = &#x27;girl&#x27;;&#125;// 为 Child3 设置原型为 Parent3 的实例Child.prototype = new Parent();// 手动设置构造器的指向，确保正确引用 Child实例既不互相影响，又能使用父类的原型属性和方法。 原型式继承利用Object.create()实现继承，括号内传入参数新建的对象原型指向。 12345678910111213141516let Parent = &#123; name: &quot;name&quot;, friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;], getName: function() &#123; return this.name; &#125; &#125;; let child1 = Object.create(Parent);// 创建 person4，原型指向 parent let child2 = Object.create(Parent); child1.name = &quot;tom&quot;; child1.friends.push(&quot;jerry&quot;); child2.friends.push(&quot;lucy&quot;); console.log(child1.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;] console.log(child2.friends); // [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;,&quot;jerry&quot;,&quot;lucy&quot;] 与原型链继承的缺点相似，造成引用类型属性的共享。 寄生式继承创建一个新的对象作为原型，然后对该对象进行扩展和修改。利用Object.create()浅拷贝的能力再进行增强，添加一些方法。 12345678910111213141516let Parent = &#123; name: name, friends: [&#x27;p1&#x27;,&#x27;p2&#x27;,&#x27;p3&#x27;], getName : function()&#123; return this.name; &#125;&#125;;function clone(original)&#123; this.sex = &#x27;girl&#x27;; let clone = Object.create(original); let getFriends = function()&#123; return this.friends; &#125;; return clone;&#125;let child = clone(Parent); 缺点与原型链继承、原型式继承类似，会出现引用类型属性的共享。 寄生组合式继承通过这种组合继承的方式，Child6、 成功继承了 Parent 的属性和方法，同时还可以定义自己的属性和方法。这种方式避免了多重构造调用，减少了内存占用。是所有继承方式里，相对最优的继承方式。 1234567891011121314151617function clone(parent,child)&#123; child.prototype = Object.create(parent.prototype);//原型式 child.prototype.constructor = child;//构造函数原型指向&#125;//寄生式function Parent() &#123; this.name = name, this.friends = [&#x27;p1&#x27;,&#x27;p2&#x27;,&#x27;p3&#x27;]&#125;Parent.prototype.getName = function()&#123; return this.name;&#125;function Child()&#123; this.sex = &#x27;girl&#x27;; Parent.call(this);//构造函数式&#125;clone(Parent,Child);let person = new Child();//原型链 注意事项通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似 谈谈对this的理解？定义绑定规则箭头函数优先级js中执行上下文和执行栈是什么？说说js中的事件模型typeof 和 instanceof 的区别？","categories":[],"tags":[]},{"title":"vue框架学习笔记","slug":"vue框架学习笔记","date":"2024-11-06T15:23:48.000Z","updated":"2024-11-11T14:23:02.740Z","comments":true,"path":"2024/11/06/vue框架学习笔记/","permalink":"https://cynthia1379.github.io/2024/11/06/vue%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"vue框架学习笔记，基于B站课程vue3+TypeScript","text":"vue框架学习笔记，基于B站课程vue3+TypeScript vue3工程基础知识基于vue_cli创建基于webpack构建工具创建，包括React框架。从入口文件进入，先将所有模块分析处理后，开始server ready。 基于vite创建与webpack等价的构建工具，构建速度快于webpack。先server ready，再根据需求分析处理。入口文件：index.html 编写组件vue.js项目中，src文件通常为存放源代码的主要目录： .&#x2F;main.js 项目的入口文件，在这里创建vue实例并挂载到页面元素上。 .&#x2F;App.vue 项目的根组件，通常包含应用的总体结构。 components 存放vue组件的文件夹，每个组件通常对应一个.vue文件 views 存放页面级别的组件，通常是路由对应的组件。例如 Home.vue、About.vue等。 router 存放路由配置相关的文件，通常是一个 index.js 文件，负责定义路由规则。 store 存放 Vuex 状态管理的相关文件。这可以包含 index.js、modules 等，处理状态管理和数据流的逻辑。 assets 存放项目的静态资源，例如图片、样式文件和字体等。 编写App组件1234567//main.ts初始内容import &#x27;./assets/main.css&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;//创建应用import App from &#x27;./App.vue&#x27; //APP组件为所有组件的根组件createApp(App).mount(&#x27;#app&#x27;)//mount挂载，将此组件摆在id为app的div中 123456789101112131415161718192021222324//自己编写的App组件//App.vue的三种标签&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h1&gt; hello,vue! &lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//JS或TS export default&#123; name : &#x27;App&#x27;//组件名 &#125;&lt;/script&gt;&lt;style&gt;/* 样式 */ .app&#123; background-color: red; box-shadow: 0 0 10px; border-radius: 10px;//边框圆角效果，参数控制圆弧半径 padding:20px;//内边距：元素边框与内容之间的空间 &#125;&lt;/style&gt; 组件实现一个简单的效果main.ts内容不变，新建components文件夹下’.vue’文件创建组件，并将其引入至App.vue。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Person.vue&lt;template&gt; &lt;div class = &#x27;person&#x27;&gt; &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;button @click=&#x27;showTel&#x27;&gt;查看联系方式&lt;/button&gt;//&lt;!--@click=&#x27;xxx&#x27;&#x27;,绑定事件--&gt; &lt;button @click=&#x27;changeName&#x27;&gt;修改名字&lt;/button&gt; &lt;button @click = &#x27;changeAge&#x27;&gt;修改年龄&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt; export default&#123; name:&#x27;Person&#x27;,//需要给此组件命名 data()&#123; return&#123; name:&#x27;张三&#x27;, age:18, tel:&#x27;180-xxxx-xxxx&#x27; &#125; &#125;, methods:&#123; showTel()&#123; alert(this.tel); &#125;, changeName()&#123; this.name = &#x27;王五&#x27;; &#125;, changeAge()&#123; this.age += 1; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .person&#123; background-color: skyblue; box-shadow: 0 0 10px; border-radius: 10px; padding:20px; &#125; button&#123; margin:0 5px; &#125;&lt;/style&gt; 1234567891011121314151617181920212223242526//App.vue&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h1&gt; hello,vue! &lt;/h1&gt; &lt;Person/&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;//JS或TS import Person from &#x27;./components/Person.vue&#x27; //导入组件 export default&#123; name : &#x27;App&#x27;, components:&#123;Person&#125;//注册组件 &#125;&lt;/script&gt;&lt;style&gt;/* 样式 */ .app&#123; background-color: red; box-shadow: 0 0 10px; border-radius: 10px; padding:20px; &#125;&lt;/style&gt; Vue3核心语法OptionsAPI 与 CompositionAPI vue2-OptionsAPI式（选项式）：数据、方法、计算属性等是分散在：data、methods、computed中的，若想修改一个需求，则需分别修改data、methods、computed，不便于维护和复用 vue3-CompositionAPI式（组合式）：通过 setup 函数，您可以自由地组织和复用逻辑，相同逻辑可以使用 composable 函数进行抽离。使用 ref 和 reactive 来创建响应式数据，能更好地控制数据传递和状态管理。 setupsetup概述123456789101112131415161718192021222324252627&lt;!-- Person.vue --&gt;&lt;script&gt; export default&#123; name:&#x27;Person&#x27;, //setup函数中的this是undefined，vue3中已开始弱化this setup()&#123; //数据 //注意：此时定义的name/age均非响应式数据，改变不会自动更新到视图 let name = &#x27;张三&#x27;; let age = 18;//如此修改，界面不变，但却是进行了修改 let tel = 13800001111; //方法 function changeName()&#123; name = &#x27;李四&#x27;; &#125; function changeAge()&#123; age +=1; &#125; function showTel()&#123; alert(tel) &#125; return &#123;name,age&#125; &#125; &#125;&lt;/script&gt; setup的返回值setup返回值可以是一个函数，直接指定渲染的内容。 12345setup()&#123; &lt;!-- 省略 --&gt; return ()=&gt;哈哈 &lt;!-- 页面打印哈哈 --&gt;&#125; setup与OptionsAPI二者可以共存，OptionsAPI可以通过this读取setup中的数据，setup()不可以读取data()、methods. setup的语法糖1234567891011121314151617181920&lt;script&gt; export default&#123; name:&#x27;Person&#x27;, &#125;&lt;/script&gt;&lt;!-- 两个script不能合并 --&gt;&lt;script setup&gt;//无需return let name = &#x27;张三&#x27;; let age = 18; let tel = 13800001111; function changeName()&#123; name = &#x27;李四&#x27;; &#125; function changeAge()&#123; age +=1; &#125; function showTel()&#123; alert(tel) &#125;&lt;/script&gt; 安装了插件npm i vite-plugin-vue-setup-extend后，可简化组件命名步骤： 12&lt;script setup name=&#x27;Person&#x27;&gt;&lt;/script&gt; 第一步：npm i vite-plugin-vue-setup-extend -D 第二步：vite.config.ts123456import &#123; defineConfig &#125; from &#x27;vite&#x27;import VueSetupExtend from &#x27;vite-plugin-vue-setup-extend&#x27;export default defineConfig(&#123; plugins: [ VueSetupExtend() ]&#125;) 响应式数据ref创建_基本类型的响应式数据你想让哪个数据是响应式，就用ref将数据包一下。 123import &#123;ref&#125; from &#x27;vue&#x27;//需要先进行引用let name = ref (&#x27;张三&#x27;);let age = ref(18); ref本质是函数，将被包的数据变为对象，在js中操控其值时，需要使用.value，就算是引用类型也要.value 123function changeName()&#123; name.value = &#x27;王五&#x27;；&#125; reactive创建_对象类型的响应式数据只能定义对象类型的响应式数据，用reactive去包。reactive可以定义深层次数据。 1234567891011121314151617181920&lt;template&gt; &lt;div class = &#x27;car&#x27;&gt; &lt;h2&gt;游戏列表： &lt;ul&gt; &lt;li v-for=&quot;g in game&quot; :key = &#x27;g.id&#x27;&gt;&#123;&#123; g.gameName &#125;&#125;&lt;/li&gt; &lt;!-- v-for --&gt; &lt;/ul&gt; &lt;/h2&gt; &lt;button @click=&quot;changeName&quot;&gt;修改游戏名称&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup name = &#x27;Person&#x27;&gt; import &#123;reactive&#125; from &#x27;vue&#x27;; let game =reactive( [&#123;id:801, gameName:&#x27;王者荣耀&#x27;&#125;, &#123;id:802, gameName:&#x27;原神&#x27;&#125;, &#123;id:803, gameName:&#x27;梦境侦探&#x27;&#125;]) function changeName()&#123; game[0].gameName = &#x27;蛋仔派对&#x27;;//正确引用数组类型对象 &#125;&lt;/script&gt; ref创建_对象类型的响应式数据表面上，是用ref定义了一个对象类型的响应式数据，但本质上，还是使用的reactive。注意！！！使用ref定义的响应式数据，需要.value，可以使用插件添加 12345678910let car = ref(&#123;brand:&#x27;奔驰&#x27;,price:100&#125;)let game = ref([ &#123;id:alkjdnl01,name:&#x27;王者荣耀&#x27;&#125;, &#123;id:alkjdnl01,name:&#x27;原神&#x27;&#125;, &#123;id:alkjdnl01,name:&#x27;第五人格&#x27;&#125;,])function changeData()&#123; car.value.price += 10; game.value[0].nama = &#x27;蛋仔派对&#x27;;//注意[0]和.value的位置！！！&#125; ref对比reactive的使用场景宏观角度看： ref用来定义：基本类型数据、对象类型数据； reactive用来定义：对象类型数据。 区别： ref创建的变量必须使用.value（可以使用volar插件自动添加.value）。 reactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换）。 使用原则： 若需要一个基本类型的响应式数据，必须使用ref。 若需要一个响应式对象，层级不深，ref、reactive都可以。 若需要一个响应式对象，且层级较深，推荐使用reactive。 12345let car = reactie(&#123;brand:&#x27;宝马&#x27;,price:100&#125;)function changeCar()&#123; // car = &#123;brand:&#x27;奔驰&#x27;,price:200&#125;//即区别2，失去响应式，页面不更新 Object.assign(car,&#123;brand:&#x27;奔驰&#x27;,price:200&#125;)&#125; ref则可以直接整体修改，有.value则必是响应式 1234let car = ref(&#123;brand:&#x27;宝马&#x27;,price:100&#125;)function changeCar()&#123; car.value = &#123;brand:&#x27;奔驰&#x27;,price:200&#125;&#125; 同时，ref不能越过.value直接更改数据内容 12345let sum =ref(0)function changeSum()&#123; sum = ref(9)//绕过.value错误，不更改 sum.value += 1//正确操作&#125; toRefs与toReftoRefs 是一个函数，它接受一个响应式对象，将该对象的属性转换为响应式引用（ref），并返回一个新对象。这样可以确保在解构属性时仍然保持它们的响应性。toRef 用于将响应式对象中的单个属性转换为响应式引用。 12345678910111213import &#123;reactive,toRefs，toRef&#125; from vuelet person = &#123; name = &#x27;张三&#x27;, age = 18&#125;let &#123;name , age&#125; = toRefs(person)//let &#123;name,age&#125; = person 等价于 let name = person.name; let age = person.age，同时将name与person.name相关联，改变name也将改变person.name，age同理//简化代码，提高可读性let nl = toRef(person,&#x27;age&#x27;)//同理，改变nl值，person.age也会变化function changePerson()&#123; name.value = &#x27;里斯&#x27; age.value += 1&#125; computed计算属性computed（计算属性）是用于根据其他数据动态计算的属性。计算属性可以依赖于Vue实例中的某些数据，当这些数据发生变化时，计算属性会自动重新计算。同时，计算属性拥有缓存，当数值没变，多次调用相同结果时，只计算一次，方法不会。计算结果是由ref定义的响应式数据。 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class = &#x27;person&#x27;&gt; 姓：&lt;input type = &#x27;txt&#x27; v-model=&quot;firstName&quot;&gt;&lt;br&gt; 名：&lt;input type = &#x27;txt&#x27; v-model=&quot;lastName&quot;&gt;&lt;br&gt; 全名：&lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;&lt;br&gt; &lt;button @click=&quot;changeFullname&quot;&gt;修改全名为li-si&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup name = &#x27;Person&#x27;&gt; import &#123;ref,computed&#125; from &#x27;vue&#x27; let firstName = ref(&#x27;zhang&#x27;) let lastName = ref(&#x27;san&#x27;) //这样定义的计算属性只读，不可修改// let fullName = computed(()=&gt;&#123;// return firstName.value+&#x27;-&#x27;+lastName.value// &#125;) //这样定义的计算属性可读可写 let fullName = computed(&#123; get()&#123; return firstName.value.slice(0,1).toUpperCase()+firstName.value.slice(1)+&#x27;-&#x27;+lastName.value &#125;, set(val)&#123;//根据下方修改的函数获取fullName的新值 let arr = val.split(&#x27;-&#x27;); firstName.value = arr[0]; lastName.value = arr[1]; &#125; &#125;) function changeFullname()&#123; fullName.value = &#x27;li-si&#x27; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; watch监视vue3中的watch只能监视以下四种数据： ref定义的数据（sum是，sum.value不是）reactive定义的数据函数返回一个值（getter函数）一个包含上述内容的数组 情况一监视ref定义的基本类型数据：直接写数据名即可，监视的是其值value值的改变 情况二情况三情况四watchEffect标签的ref属性props的使用对生命周期的理解自定义Hooks","categories":[],"tags":[]},{"title":"hexo个人博客","slug":"hexo博客","date":"2024-10-29T03:59:33.000Z","updated":"2024-11-06T14:49:35.430Z","comments":true,"path":"2024/10/29/hexo博客/","permalink":"https://cynthia1379.github.io/2024/10/29/hexo%E5%8D%9A%E5%AE%A2/","excerpt":"基于Node.js的静态博客生成器Hexo的使用方法","text":"基于Node.js的静态博客生成器Hexo的使用方法 环境配置Node.js安装及环境配置参考教程安装Node.js，可以从Node.js官网下载对应版本的安装包进行安装。安装完成后，打开命令提示符，输入node -v命令，查看是否安装成功。并配置环境变量，在Node.js的安装目录下新建文件夹，将文件夹添加到PATH环境变量中。参考教程中第五步安装淘宝镜像，可以提高下载速度，但无需配置。 Hexo安装及环境配置在目标位置创建一个blog文件夹，并在该文件夹下打开命令提示符，输入npm install hexo-cli -g命令，安装Hexo。 1npm install hexo-cli -g 安装完成后，输入hexo -v命令，查看Hexo版本。 1hexo -v 创建博客：输入hexo init命令，Hexo会在当前文件夹下创建一个名为hexo的文件夹，该文件夹就是博客的根目录。也可输入hexo init blog命令，创建名为blog的文件夹。新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 12hexo inithexo init blog 启动博客：输入hexo server命令(缩写为hexo s)，Hexo会启动一个本地服务器，默认端口为4000，访问http://localhost:4000即可看到博客的首页。 git与GitHub配置参考教程 安装并配置git：git下载官网下载安装包，安装后，打开命令提示符，输入git --version命令，查看是否安装成功。 1git --version 新建并初始化本地仓库：在博客根目录下，鼠标右键Git Bash Here，打开Git Bash命令行，输入git init命令，初始化本地仓库。 1git init 设置git本地仓库用户名与邮箱 12git config --global user.name &quot;your_name&quot;git config --global user.email &quot;your_email@example.com&quot; 注：查看设置的用户名和邮箱 12git config --global user.namegit config --global user.email 配置GitHub并远程连接：注册GitHub账号，并登录GitHub网站。创建SSH Key：打开git bash命令行，输入ssh-keygen -t rsa -C &quot;your_email@example.com&quot;命令，按下三次回车，生成SSH Key。注：若此仓库之前已经关联过GitHub仓库，则需要先删除原有SSH Key，再重新生成。或关注提示信息：已有ssh key，是否覆盖，输入y后回车。 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 查看SSH Key：打开命令提示符，输入cat ~/.ssh/id_rsa.pub命令，查看SSH Key，鼠标右键复制。 1cat ~/.ssh/id_rsa.pub 添加SSH Key到GitHub：打开GitHub网站，点击右上角头像，选择Settings，选择SSH and GPG keys，点击New SSH Key，将SSH Key内容粘贴到Key文本框，并输入Title，点击Add SSH Key。关联本地仓库与GitHub仓库：在博客根目录下，输入git remote add origin https://github.com/your_name/your_repository.git命令，关联本地仓库与GitHub仓库。由于此连接方式需要网络稳定，所以采用SSH Key的方式： 1git remote add origin git@github.com/your_name/your_repository.git 检查仓库是否添加成功：输入git remote -v命令，查看仓库是否添加成功。 关联GitHub仓库：在GitHub网站上新建一个仓库，仓库名’&lt;github_用户名&gt;.github.io’ 1git remote add origin git@github.com/your_name/your_repository.git 注：将your_name替换为你的GitHub用户名，your_repository替换为你新建的仓库名。 hexo博客管理Hexo提供了丰富的主题，可以在此网站根据个人喜好选择适合自己的主题。 hexo主题安装安装主题在博客根目录下，输入npm install hexo-theme-xxx --save命令，安装主题。 1npm install hexo-theme-xxx --save 或直接在此网站中点击喜欢主题的名称，跳转到主题的GitHub主页，点击Download按钮，下载主题压缩包，解压后，将主题文件夹重命名为hexo-theme-xxx，放入博客根目录下的themes文件夹中。 启用主题在博客根目录下，打开主题配置文件_config.yml，根据主题说明进行配置。以下是我的博客的主题hipaper配置：theme.png](https://imgse.com/i/pAyPsVe) 文章&#x2F;页面内容管理网站基本信息配置网站标题作者等内容均可在根目录中_config.yml文件中修改。 创建文章&#x2F;页面在博客根目录下，输入hexo new &quot;文章/页面标题&quot;命令，创建文章&#x2F;页面。 1hexo new &quot;文章/页面标题&quot; 编辑文章&#x2F;页面在博客根目录下，打开source/_posts文件夹，找到刚才创建的文章&#x2F;页面，编辑内容。内容格式markdwon，参考Markdown语法。 本地预览文章&#x2F;页面在博客根目录下，输入hexo server命令，启动本地服务器，预览文章&#x2F;页面。 1hexo server 提交代码并推送到GitHub在博客根目录下，输入hexo clean命令，清除缓存文件。 1hexo clean 输入hexo g命令，生成静态页面，即在public文件夹中生成静态文件。 1hexo g 修改_config.yml文件url配置和deploy配置。 1url: https://your_name.github.io 1234deploy: type: git repo: &lt;EMAIL&gt;:your_name/your_repository.git branch: main 输入hexo d命令，部署静态页面到GitHub仓库，同时生成.deploy_git文件夹，该文件夹中存放的是部署到GitHub仓库所需的全部文件。虽然url大小写敏感，但在生成过程中仍有可能出现大小写不一致的情况，所以建议将url配置为全小写。 1hexo d GitHub Pages部署GitHub Pages页面设置位于GitHub仓库设置-pages设置下，配置过程可在actions中查看。注意pages设置中，source和branch的配置。页面配置成功后，出现蓝色方框内容。pagesetting.png](https://imgse.com/i/pAyi9IJ)","categories":[{"name":"编程学习","slug":"编程学习","permalink":"https://cynthia1379.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"node.js,hexo,博客","slug":"node-js-hexo-博客","permalink":"https://cynthia1379.github.io/tags/node-js-hexo-%E5%8D%9A%E5%AE%A2/"}]},{"title":"力扣刷题笔记","slug":"力扣刷题笔记","date":"2024-10-10T09:26:08.000Z","updated":"2024-10-29T10:36:19.504Z","comments":true,"path":"2024/10/10/力扣刷题笔记/","permalink":"https://cynthia1379.github.io/2024/10/10/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"2024年力扣刷题笔记","text":"2024年力扣刷题笔记 简单难度计数器请你写一个函数 createCounter。这个函数接收一个初始的整数值 init。并返回一个包含三个函数的对象。这三个函数是：increment() 将当前值加 1 并返回。decrement() 将当前值减 1 并返回。reset() 将当前值设置为 init 并返回。 1234567891011121314151617var createCounter = function(init)&#123; let count = init; return&#123; increment:function()&#123; count++; return count; &#125;, decrement:function()&#123; count--; return count; &#125;, reset:function()&#123; count = init; return count; &#125; &#125;&#125; 定义一个新对象，直接用大括号引入，或用对象字面量&#x2F;构造函数&#x2F;class语法&#x2F;object.create()方法创建 方法间用逗号隔开，并用冒号 : 进行定义 数组原型对象的最后一个元素请你编写一段代码实现一个数组方法，使任何数组都可以调用 array.last() 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 -1 。 12345678Array.prototype.last = function() &#123; if (this.length == 0)&#123; return -1; &#125;else&#123; let len = this.length; return this[len - 1]; &#125;&#125;; 注意：在函数中并未传入数组参数，使用this指向调用该方法的对象 睡眠函数请你编写一个异步函数，它接收一个正整数参数 millis ，并休眠 millis 毫秒。要求此函数可以解析任何值。 123456789示例 1：输入：millis = 100输出：100解释：在 100ms 后此异步函数执行完时返回一个 Promise 对象let t = Date.now();sleep(100).then(() =&gt; &#123; console.log(Date.now() - t); // 100&#125;); 12345async function sleep(millis) &#123; return new Promise(（resolve） =&gt;&#123; setTimeout(() =&gt; &#123;resolve(millis)&#125;, millis); &#125; &#125; 题目要求返回一个对象 利用resolve参数，改变Promise状态，进而传递参数 Promise是Js的一个内置对象，用于表示一个异步操作的状态，而不是所有对象都是new Promise() 生成斐波那契数列请你编写一个生成器函数，并返回一个可以生成 斐波那契数列 的生成器对象。斐波那契数列 的递推公式为 Xn &#x3D; Xn-1 + Xn-2 。这个数列的前几个数字是 0, 1, 1, 2, 3, 5, 8, 13 。 1234567891011var fibGenerator = function*() &#123; let a = 0; let b = 1; let c; while(1)&#123; yield a; c = a; a = a + b; b = c; &#125;&#125; yield：是js中用来定义生成器函数的关键字，可在函数中暂停执行，并返回一个值，下次调用next（）方法时，从上次暂停的地方继续执行 生成器函数：通过在函数定义前加上星号 * 来创建一个生成器函数，例如 function* myGenerator() {} 数组分块给定一个数组 arr 和一个块大小 size ，返回一个 分块 的数组。分块 的数组包含了 arr 中的原始元素，但是每个子数组的长度都是 size 。如果 arr.length 不能被 size 整除，那么最后一个子数组的长度可能小于 size 。你可以假设该数组是 JSON.parse 的输出结果。换句话说，它是有效的JSON。请你在不使用 lodash 的函数 _.chunk 的情况下解决这个问题。 1234567var chunk = function(arr, size) &#123; const arrRes = []; while(arr.length) &#123; arrRes.push(arr.splice(0, size)); &#125; return arrRes;&#125;; 使用数组常用方法splice或slice解决 包装数组创建一个名为 ArrayWrapper 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：当使用 + 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。当在实例上调用 String() 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，[1,2,3] 。 123456789101112var ArrayWrapper = function(nums) &#123; // 将传入的数组赋值给实例属性 this.nums = nums;&#125;;ArrayWrapper.prototype.valueOf = function() &#123; // 计算数组中所有元素的和并返回 return this.nums.reduce((sum, num) =&gt; sum + num, 0);&#125;ArrayWrapper.prototype.toString = function() &#123; // 将数组转换为字符串格式 return `[$&#123;this.nums.join(&#x27;,&#x27;)&#125;]`;&#125; 模板字符串，${}引用表达式 使用 throw new Error(‘这是一个错误信息’) 抛出异常 执行可取消的延迟函数给定一个函数 fn ，一个参数数组 args 和一个以毫秒为单位的超时时间 t ，返回一个取消函数 cancelFn 。在 cancelTimeMs 的延迟后，返回的取消函数 cancelFn 将被调用。setTimeout(cancelFn, cancelTimeMs)最初，函数 fn 的执行应该延迟 t 毫秒。如果在 t 毫秒的延迟之前调用了函数 cancelFn，它应该取消 fn 的延迟执行。否则，如果在指定的延迟 t 内没有调用 cancelFn，则应执行 fn，并使用提供的 args 作为参数。 12345678910示例 1:输入：fn = (x) =&gt; x * 5, args = [2], t = 20输出：[&#123;&quot;time&quot;: 20, &quot;returned&quot;: 10&#125;]解释：const cancelTimeMs = 50;const cancelFn = cancellable((x) =&gt; x * 5, [2], 20);setTimeout(cancelFn, cancelTimeMs);取消操作被安排在延迟了 cancelTimeMs（50毫秒）后进行，这发生在 fn(2) 在20毫秒时执行之后。 12345678Var cancellable = function(fn,args,t)&#123; let timeoutID; const cancelFn = function()&#123; clearTimeout(timeoutID); &#125; timeoutID = setTimeout(()=&gt;&#123;fn(args);&#125;,t); Return cancelFn;&#125; 注意题目中对cancelFn的功能需求，第二个setTimout函数是在cancellable之外执行，本很熟只需要创建一个函数，调用能取消setTimeout的函数即可 排序方式给定一个数组 arr 和一个函数 fn，返回一个排序后的数组 sortedArr。你可以假设 fn 只返回数字，并且这些数字决定了 sortedArr 的排序顺序。sortedArr 必须按照 fn 的输出值 升序 排序。 1234var sortBy = function(arr, fn) &#123; let sortedArr = arr.sort((a,b)=&gt;fn(a)-fn(b)); return sortedArr&#125; .sort()方法可以接收一个比较函数，该函数接收两个参数，返回一个负数、零或正数，用来决定两个元素的相对顺序。负数：第一个参数排在第二个参数前；正数：第一个参数排在第二个参数后；零：两个参数相等。 间隔取消（setTimeout重复调用）现给定一个函数 fn，一个参数数组 args 和一个时间间隔 t，返回一个取消函数 cancelFn。 在经过 cancelTimeMs 毫秒的延迟后，将调用返回的取消函数 cancelFn。 setTimeout(cancelFn, cancelTimeMs)函数 fn 应立即使用参数 args 调用，然后每隔 t 毫秒调用一次，直到在 cancelTimeMs 毫秒时调用 cancelFn。 1234567891011121314151617var cancellable = function(fn, args, t) &#123; let timeoutID; let status = true; const cancleFn = function()&#123; clearTimeout(timeoutID); status = false; &#125; const repeatsetTime = function()&#123; if(status)&#123;//判断条件在函数内部进行循环 fn(...args);//使用...args展开参数数组，fn接收任意数量的参数 timeoutID = setTimeout(repeatsetTime,t);//每次都调用repeatsetTime，而非fn（...args） &#125; &#125; fn(...args); timeoutID = setTimeout(repeatsetTime,t);//启动第一次调用 return cancleFn;&#125;; 也可以使用setInterval实现间隔调用，但是需要注意 clearInterval的使用 正确的幂运算 result &#x3D; Math.pow(a,x) 判断为空给定一个对象或数组，判断它是否为空。 一个空对象不包含任何键值对。一个空数组不包含任何元素。你可以假设对象或数组是通过 JSON.parse 解析得到的。 12345678910111213 var isEmpty = function(obj) &#123; if(Array.isArray(obj))&#123; if(obj.length == 0)&#123; return true &#125;else&#123; return false &#125; &#125;else if(typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null)&#123; return Object.keys(obj).length === 0; &#125;else&#123; return false &#125;&#125;; typeof null &#x3D;&#x3D;&#x3D; ‘object’，所以需要判断null Object.keys()返回一个数组，包含对象obj的键值;length属性返回数组的长度","categories":[{"name":"编程学习","slug":"编程学习","permalink":"https://cynthia1379.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cynthia1379.github.io/tags/leetcode/"}]},{"title":"UI学习记录","slug":"UI学习记录","date":"2022-10-14T15:08:26.000Z","updated":"2024-10-29T10:36:19.495Z","comments":true,"path":"2022/10/14/UI学习记录/","permalink":"https://cynthia1379.github.io/2022/10/14/UI%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"设计一款焦糖风格的宠物分享平台app~猫猫云！","text":"设计一款焦糖风格的宠物分享平台app~猫猫云！ 任务信息任务一设计该app的图标，具有焦糖特色，创新简洁，工具不限 任务二为这个app取一个好听的名字，并写一份需求分析文档，说明app的基本功能，业务逻辑等该app需包含用户发帖分享宠物日常的基本功能，另需增加至少一项其他与宠物相关的功能模块 任务三绘制该app的原型图，机型不限，需具有焦糖特色 做题基本流程： 1、读题：先读题目，获取信息，明确要求； 2、破题：根据信息，大范围搜集资料，知道题目到底在说些什么， 3、入题：落实要求，开始试错；只有真正开始上手做了，才会知道缺少什么。 4、做题1：根据试错版本，知道自己的知识与经验瓶颈。再深入搜集信息，学习知识。 5、做题2：根据新信息，改善试错版本&#x2F;开始新版本。 6、做题3：不断重复步骤四五，丰富信息，打磨版本。 7、结题：汇总整理前期的做题记录，作结论，写报告。 任务一：APP图标所以，在第四题题目中获取基本信息之后，我下载了Photoshop，搜集市面上所有宠物相关的软件图标，浅找了网课学习，浅回顾了高中美术课的图标设计有关内容（感谢老师，认真讲了，感谢自己，认真学了，认真画了）开始试错任务一：软件图标。 版本一题目限制条件：1、宠物软件；2、焦糖风格；3、创新简洁。 个人条件：我，一个只会简单ps操作的入门选手，没有数位板，没有pad，纯手绘一个创新、简洁且美观的图标，不太现实。 解题思路：感谢相关参考资料的建议，以及前两年系统化自学PPT积累的图片与图标资源，我迅速的决定“改图”。从网络中找到合适的图片资源，再在图片的基础上，通过ps，进行融图和修改。（融图：把焦糖图标和找到的图片融合到一起） 在花瓣网上，我找到了特别合适的融图资源。把中间的猫猫抠出来，再把中间的盘子换成焦糖的图标。在此基础上，对照着图标的规格大小，规范化图片。perfect！宠物——可爱的风格，代表性的猫猫 焦糖风格——焦糖的图标还不够代表焦糖嘛？ 创新简洁——猫猫都简笔画了，当然问题不大。至于焦糖图标不够简单，我把图标颜色调简单一点，解决！ 看起来似乎不错，但是，当我关上电脑，打开手机，盯着那一片的图标，我陷入沉默。这个图标满足要求吗？满足。但是，它真的看起来不像一个图标啊！！！我把图标导出为png图片，放在桌面上，和一众电脑图标对比，这种感觉就更加强烈了。分析一下原因： 1、我在简洁性上自我欺骗； 2、就算它和“国家反炸中心”的警徽对比起来，足够简洁，它看起来也不像一个宠物分享平台的图标。猫猫并不是主体，内容与宠物分享风马牛不相及； 3、元素杂糅，画风微妙。 以上，促使我做出了版本二。 版本二严格意义上，它甚至不能算是一个版本，算是我的一个没有结果的尝试。同样的融图思路，不同的启发图片。比如，将月亮换成焦糖图标，又比如，放大猫猫，将猫猫变得焦糖一点。从我连结果都没有导出，就可以发现，我的尝试比较失败。 分析原因： 1、这个猫猫剪影不够简洁，图片来源是是摄影而不是绘画设计。二次创作难以简洁化图片。 2、黑白剪影好看的前提是简洁的背景（如：虚化后的月亮，纯色），如果将黑白剪影的元素强行与焦糖杂糅，还是会很奇怪。 3、将黑白猫猫焦糖化在这个图片里不合理且不会好看。 4、图标往往有格式限制，强制性的由圆转方，减少留白，图片也失去了它原本的意蕴。 至此，陷入小的僵局。 僵局 顺势进入做题步骤四，我再次研究了市面上所有的软件图标（重点：宠物相关软件）。发现以下几类： 1、用汉字或英文直接重复软件名字+设计感的字+和软件页面契合的配色（如：bilibili，唯品会，天府通，小红书，翼支付，咸鱼）这个方案十分可行，在所有软件图标中占比也大，然而作为招新题，交上去真的有点太水了。 2、软件代表的吉祥物做图标（如：QQ，菜鸟京东，天猫，淘特，QQ阅读，虎牙直播，AcFun）这个设计方案对绘画要求更高。 3、抽象表意符号做图标，这种抽象表意符号，往往和软件名或者软件内容有关系。（如：网易云音乐，QQ音乐，剪映，抖音，快手，芒果TV） 同时灵活运用“git&amp;GitHub”中学到的破局之法，回顾分析试错内容： 1、融合焦糖元素时，不要过分生硬，直接把logo贴上去。 2、黑白剪影是可行的，可图片还需要经过精心挑选，融合方式也要再做考虑。 3、选取的图片素材尽可能风格较明显，或者风格较弱，比较方便融合焦糖元素。 版本三由于我认为黑白剪影是可以再尝试的内容，所以再次寻找了可以的黑白剪影猫猫图。我在ps中设置了两个图层，图层一猫猫剪影，图层二放大的焦糖logo。通过蒙版抠图，剪影的黑白色被替换为了焦糖条纹🙂。经过一系列细节调整后，我又又又又又又又发现了问题：这个猫猫整体偏长，做成图标尺寸后，要么尾巴在图像外。要么猫猫主体偏小。这个猫猫过细的身体配上焦糖条纹，略显奇怪。 版本四剪影猫猫的思路是正确的，如何在放大猫猫主体的基础上，展现焦糖风格呢？猫猫主体主要体现在猫猫的头部形状上，那么抛弃偏长的身体，重新使用钢笔工具进行简单绘制，就能得到一张全新的、简洁的焦糖猫猫图标。思路已经有了，但如何以我不高的绘画水平进行绘制仍是问题。看着电脑上残存的猫猫头，我再次神游起来：这个软件应该叫什么名字呢？毕竟，那么多软件图标的母亲都是软件的名字。这个软件名，既要和宠物有关系，又要体现它的功能：宠物分享平台。可能受到猫猫之神的启发，可能因为出题的学姐称“猫”为“猫猫”，我突然灵光一闪：猫猫云！互联网上云吸猫，云养猫，“云”一字不正能体现这个平台的作用嘛？！ 软件名字定了——“猫猫云”，再细看这个猫猫头，它那长长的两根胡须，简直像极了“云”字上面的两条横线。把猫猫头单拎出来，打开钢笔功能，改路径为形状，以云的下半部分为模板，绘制猫猫身体。你别说，有模有样，我特别满意。我的猫猫云图标也就确定下来了：再根据相同方式，与焦糖logo进行融合，挑选配色及融合方案，得到最终的图标。 任务二三 需求文档及原型图我的做题顺序：1、查找相关资料，了解需求文档与原型图是什么，怎么画； 2、写需求文档目录，设计“猫猫云”基本功能； 3、画产品结构图，主要业务流程图； 4、根据上述两图，绘制原型图； 5、根据需求文档目录，完善文档内容； 过程总结上述做题顺序看起来岁月静好，无波无浪，然而，在需求文档首次书写中，遇见了很多问题： 1、软件功能设计的纠结和不自信，导致我在今天10月4日，还在思考这个功能需不需要增加。 2、信息的混杂，需求文档标准的模糊，让我中途停下，怀疑各种内容，对文档进行反复的细枝末节的修改，耽误时间并且举足不前，不敢往下继续书写。 3、对于信息来源的忽视，系统的网课其实能比较好的解决问题二，可这条解决方法被我一直忽略。没有总结整理出来一套有逻辑的完整的信息获取路径。 4、我采用的原型软件是XD，我以七天试用期为截止时间，高效完成了原型图的绘制。得不到的永远在骚动？试用期过了大概四五天，我就对我的原型图再次百般不满，想改又买不起软件。用盗版，又担心网上的链接不安全。感谢崔导，提醒我，还有淘宝这种好东西！ 5、交互说明编写说明编号，画原型图过程中据逻辑顺序给原型图编号，导致交互说明中的编号显得比较混乱，没有逻辑顺序。 6、非功能需求的技术含量与专业名词相对较多，ddl人在马拉松时期没有完成系统化的学习和了解； 🙂10月13日的我，看着最后24h的截止时间，本打算再肝一肝需求文档。但是，markdown文档中的图片链接出现了问题。。。目前我只能靠我的pdf勉强维生&#x2F;(ㄒoㄒ)&#x2F;~~。就，再挣扎最后一天吧。。。","categories":[{"name":"编程学习","slug":"编程学习","permalink":"https://cynthia1379.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"UI设计","slug":"UI设计","permalink":"https://cynthia1379.github.io/tags/UI%E8%AE%BE%E8%AE%A1/"}]},{"title":"虚拟机搭建","slug":"虚拟机搭建","date":"2022-09-12T14:14:30.000Z","updated":"2024-10-29T10:36:19.504Z","comments":true,"path":"2022/09/12/虚拟机搭建/","permalink":"https://cynthia1379.github.io/2022/09/12/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BA/","excerpt":"初学搭建虚拟机环境，记录一下自己的自学过程，为之后自学路径优化提供参考。","text":"初学搭建虚拟机环境，记录一下自己的自学过程，为之后自学路径优化提供参考。 在虚拟机软件中安装配置 Ubuntu 发行版读懂陌生名词 虚拟机：虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。 Ubuntu：Ubuntu是一个以桌面应用为主的Linux操作系统。 搜索教程，步步跟随浅安利一下这个教程，讲的特别清楚！https://blog.csdn.net/weixin_43290551/article/details/125954709 下载虚拟机软件 官网下载https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion 下载Ubuntu镜像文件 下载ubuntuhttps://releases.ubuntu.com/ 创建虚拟机，在虚拟机中配置Linux环境 跟着教程一步一步地安装虚拟机，配置环境。 根据教程与下载提示步步进行 注意在自定义硬盘中完成CD的配置 完成下载，在开机中断开网络适配器连接 完成虚拟机基础设置（语言、时区、用户名、密码……） 重启 通过 VScode 的 Remote 插件连接至你的虚拟机找教程https://blog.csdn.net/weixin_44260459/article/details/123205034https://blog.csdn.net/weixin_44260459/article/details/121772911?spm=1001.2101.3001.6650.1 心得体会在学习一个全新操作时或者下载软件时，先了解这个东西是什么（虽然不一定看得懂），再进一步的搜索教程，沿着一份情况与自己相似的教程前进。当遇到难点卡住时，弄清问题本质：这一步是在配置ssh，还是查找ip地址，然后，再搜索本质问题寻找答案。这样的搜索过程效率更高。另外，养成记录的习惯，不要事后因为要交截图才去重新截图。git的存在价值是项目管理，同理，步步截屏，写markdown文档的过程也是在项目管理。记录下来，下一次遇到相同问题才会有解决思路，遇到不同问题，也能学会怎么解决。","categories":[{"name":"编程学习","slug":"编程学习","permalink":"https://cynthia1379.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://cynthia1379.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"git&markdown学习记录（一）","slug":"远程仓库链接","date":"2022-09-09T09:35:03.000Z","updated":"2024-10-29T10:36:19.505Z","comments":true,"path":"2022/09/09/远程仓库链接/","permalink":"https://cynthia1379.github.io/2022/09/09/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%93%BE%E6%8E%A5/","excerpt":"大一刚入学，在学校焦糖工作室招新马拉松中，写下的第一篇markdown学习笔记。由于系统设置问题，并未成功完成git与GitHub建立远程链接，但是，从中积累通过markdown写作，并复盘操作，在诸多bug中找到解决路径的经验。","text":"大一刚入学，在学校焦糖工作室招新马拉松中，写下的第一篇markdown学习笔记。由于系统设置问题，并未成功完成git与GitHub建立远程链接，但是，从中积累通过markdown写作，并复盘操作，在诸多bug中找到解决路径的经验。 安装git安装git是我遇见的第一个槛，打得开官网却打不开下载页面。我尝试以下方法解决： 1、换个浏览器虽然现在想起来这个办法有点傻，但也不失为一种思路，而且在科普题目一中，就提到了不同的搜索引擎。所以，我舍弃了Microsoft Edge，短暂投入chorme怀抱。可事实告诉我，浏览器不是原罪。 2、翻墙翻墙是我的室友从9月6日一早就在做，做了一大半天的事儿。所以，我不用搜索，我就知道，翻墙能解决问题。However,翻墙教程千千万，翻墙路径真麻烦，更何况，翻墙违法。Then，怕网警（怕麻烦且贫穷）的我，收回了翻墙的心。（但是如果后续还要使用像GitHub这样的外网，翻墙可能才是最简单的通法吧） 3、发现核心问题：打开GitHub网站直接搜索git下载，似乎没有多的解决方案了。However，观察我无法打开的下载页面，页面标签上赫然写着一个熟悉的名字——GitHub。所以，再次搜索打开GitHub，解决方法多了起来。 快速打开GitHub网上的途径千千万，真正能用的才是好方法。原来不是我打不开这个网站，只是他的响应速度太慢了。 1、修改host这是知乎上找到的方法，大概途径是，先用IP地址查找网页，查找GitHub网站的IP地址，然后在Windows&gt;System32&gt;drivers&gt;etc&gt;hosts中把查到的IP地址用一定格式搞上去，然后再通过cmd刷新DNS解决问题。 想法很不错，可我没有更改C盘此文件的权限。这时，我想起假期看C语言网课时，老师提到的软件——notepad++。当时使用是为了有权限修改VS的源文件，使scanf函数不报错。（我懒，所以当时采用了弹幕的方法，先另存为到桌面，保存后再重新将文件拖回原位置替换） 先用另存为法更改hosts文件，好家伙，用记事本方式打开，另存为后也变成了txt文件。 再下notepad++，官网也是外网，打不开。于是在CSDN上找到了大佬分享的网盘文件，快乐下载。 当我志得意满的完成了此方法的所有步骤后，GitHub还是打不开。🙂真好。。。 2、加速器知乎靠不住，B站大学应该能顶了吧？ dev-sidecar跟着标题党学教程，《如何快速打开GitHub网站？30秒教你快速解决》。确实，他用了30s解决问题，但是，我要先打开gitee网站，注册，搜索，下载加速器……ok,fine,当我一步一步照做之后，我发现我居然搞不懂他是怎么一下子就下载下来的？！ 在哪里跌倒就要在哪里躺下，我选择换一个教程。 steam++换一个加速器，就好多了。在UP推荐的两个兼职加速器UU加速器和steam++里，我果断选择了可能被拦截的steam++，名字好听，不用天天更新，界面清爽，操作简便🙂。打开加速器，GitHub正确访问！！！ 注册GitHub，安装git 2，创建版本库在打开加速器的情况下，一切都是那么水到渠成。 学习markdown文件的创建及书写在git教程里有这样一句话：“建议你下载Visual Studio Code代替记事本。”哇哦~原来，我的下载VS时顺手下载的VScode是这么用的。原谅我迫不及待的开始学习VScode markdown的用法，同时也试验git管理。 这第一篇学习记录，也就是我的VScode markdown试验结果。 使用git管理markdown文件在反复试探怎么使用GitHub搭建图床的过程中，我终于意识到，我的repositories并没有配置成功。在执行’git remote add origin’后，git无报错。下一步，git push却会反复报错：error:src refspec main dode not match anyerror:failed to push some refs to github.com:Cynthia1379&#x2F;jotang.git 1、检验操作步骤问题我学习删去了原来的“焦糖招新”repository，和本地隐藏的git文件，严格按照教程，重新操作。虽然与教程上GitHub的操作界面有些不同，但也确认了大的步骤没有问题，问题出现在一些细节上。 2、解决“fail to push”报错在CSDN论坛中，找到了相同报错的解决方案，输入“git pull origin master”进行同步。然后，又出现了新的报错。秉承着刨根问底的精神，继续搜索新的报错：“Could not read from remote repository””please make sure you have the correct access rights and the repository exists” 得到的解答如下：原因一，git仓库的用户信息和本地的用户信息不匹配；原因二，客户端与服务端未生成 ssh key；原因三，客户端与服务端的ssh key不匹配；原因四，本地的hosts文件中没有配置IP地址和主机名的映射关系导致本地DNS无法解析出现该问题。 原因一，将仓库用户名改为本地用户名。改后再次尝试，失败。 原因二三，讲道理，我觉得不应该是这两个原因，然而由于提供的解决步骤（重新生成ssh密匙）中，加入了新的步骤，将SSH key添加到ssh-agent，我还是浅浅的试了一下，用’ssh -T &#103;&#x69;&#x74;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;‘检验，弹出语句与成功界面不符。 原因四，发帖人对此方法的描述模糊不清。反复搜索后，未果。 3、解决”Please make sure you have the correct access rights”在删除了.ssh文件下known_hosts后，再重新连接SSH密匙。别人输入“ssh -T &#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#x6d;”后输入yes回车，问题解决。我完成操作后git错乱，跳出一长串y，光标不停左右横条。🙂，小问题。 4、观察，陷入僵局当我和git的博弈陷入僵局之后，我又再次重复了一遍我能找到的解决步骤。发现了一些隐藏的问题：诸如由于多次重复操作，git连接的repository还是之前被删了的那一个。 5、写markdown整理思路，找到盲点在卡住之后，想到可以先把问题记录下来，写markdown梳理思路。以下是发现的问题： 1、在查找资料时，思维太散。为解决问题一，往往只打开一个网页，发现问题2就立刻往下思考，对问题1反而没有进行深挖； 2、在查找资料时，没有逻辑。直接忘记或者忽略了最开始还有另外一个报错。’’error:failed to push some refs to github.com:Cynthia1379&#x2F;jotang.git’’ 3、没有及时整理，在写markdown时狼狈的翻找浏览器历史记录来梳理思路，浪费了大量时间。 4、（补充）在查找解决方法时，只按部就班解决问题，没有了解每个语句的含义和本质。 解决方案：最简单的，做任务先建markdown，先梳理记录，再往后执行操作。 6、解决最初的另一个报错1、发现有可能是因为本地仓库分支和GitHub仓库分支名称不同。给本地git仓库更改分支名称后，仍然不行。 2、可能因为git本地仓库是空仓库，再次提交文件确认仓库非空后，还是不可以。报错相同。 3.仍然可能是分支问题：没有发现main分支，需要先切换到main分支。先commit，再branch，然后checkout，最后，git push 的时候报错变了😀，变成了“Could not read from remote repository”“please make sure you have the correct access rights and the repository exists”🙂 7、回到问题3\\又一次找到核心问题重新仔细阅读了一些解决方法之后，我get到了ssh -T &#x67;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;语句的含义——配置ssh，在此基础上，我又一次找到了问题的核心：kex_exchange_identification: Connection closed by remote host. Connection closed by…… 8、搜索核心问题，推进解法1、在查找”kex-exchange……“语句时，我从CSDN跳转至StackOverflow找到了解法，采用sshd -t debug，然后出现新的语句sshd:no hostkeys available – exiting 2、解决ssh启动错误：根据网上的解决方法，先输入ssh-keygen -A，再输入&#x2F;etc&#x2F;init.d&#x2F;ssh start，中间发现问题，找不到对应文件，然后再根据指令一下达后的反馈文字，找到本电脑中的文件地址”&#x2F;etc&#x2F;ssh“，成功完成指令，再运行”ssh -t”似乎也不再出现问题。然而，在尝试git push -u……时，还是不可以🙂 3、回到上一级问题kex-exchange……，按网上方法用ssh -v @来debug，然后，出现了问题bash:syntax error near unexpected token ‘newline’，再次搜索，发现不能使用尖括号输入ssh -v 语句，去掉尖括号后重试，得到debuge1：reading configuration data &#x2F;etc&#x2F;ssh&#x2F;ssh_config Could not resolve hostname password 4.继续查找问题。发现此时网络中的解决方案要么是已经尝试过的，要么语义不明，指代不清，要么货不对板，没有参考价值。 9、暂时放弃😭至此，我选择暂时放弃GitHub，尝试使用gitee，毕竟，PS和XD的试用期不等人，马拉松的期限也不等人😭 10、再次尝试作为一个ddl人，在10月13日听说我的舍友们把GitHub都配置成功了，我，emm。。。ddl人绝不认输！ 1.再次搜索教程，卸载后重新下载git； 2.进入GitHub，重新配置ssh keys； 3.新建远程与本地仓库； 4.向本地仓库提交文件； 5.卡在了提交这一步，报错内容大意为无法连接到远程仓库。无法连接的原因：无法读取远程仓库，连接被端口关闭。。。 6.我又又又找到了新的可能的失败原因：端口占用问题。打开cmd，查询端口，找到占用软件，尝试停用。🙂，占用22号端口的软件是steam++呢，尝试关闭端口也无法关闭，直接关闭steam++，端口无占用软件，但是GitHub都无法打开🙂。我浅问了我的室友采用的解决方案：一个是直接VPN翻墙，一个是连接手机热点就能流畅登录github。 7.我谢谢你，GitHub🙂","categories":[{"name":"编程学习","slug":"编程学习","permalink":"https://cynthia1379.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cynthia1379.github.io/tags/Git/"}]}],"categories":[{"name":"编程学习","slug":"编程学习","permalink":"https://cynthia1379.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"node.js,hexo,博客","slug":"node-js-hexo-博客","permalink":"https://cynthia1379.github.io/tags/node-js-hexo-%E5%8D%9A%E5%AE%A2/"},{"name":"leetcode","slug":"leetcode","permalink":"https://cynthia1379.github.io/tags/leetcode/"},{"name":"UI设计","slug":"UI设计","permalink":"https://cynthia1379.github.io/tags/UI%E8%AE%BE%E8%AE%A1/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://cynthia1379.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Git","slug":"Git","permalink":"https://cynthia1379.github.io/tags/Git/"}]}